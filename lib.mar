mod iter;
mod duration;
mod io;
mod string;
mod list;
mod hashmap;

mod ffi {
    extern {
        fn print_raw(val: any)
        fn "margarineAbort" abort(): !

        fn int_to_str(value: int): str
        fn float_to_str(value: float): str
    }
}

use iter::Iter;

fn print<T>(val: T) {
    ffi::print_raw($any(val));
}


fn println<T>(val: T) {
    print(val);
    print("\n");
}


fn type_id_of<T>(val: T): int {
    $type_id::<T>()
}


fn panic(msg: str) : ! {
    println(msg);
    ffi::abort()
}

fn assert(value: bool, msg: str) {
    if !value { panic(msg) }
}


impl Range {
    fn __next__(self): Option<int> {
        if self.min < self.max {
            self.min += 1;
            some(self.min-1)
        } else {
            none()
        }

    }


    fn iter(self): Iter<int> {
        Iter {
            next: || self.__next__()
        }
    }

}


struct Box<T> { value: T }


impl<T> Box<T> {
    fn new(value: T): Box<T> { Box { value } }
}



impl int {
    fn abs(self): int {
        var mask = self >> 63;
        (self ^ mask) - mask
    }


    fn to_str(self): str {
        ffi::int_to_str(self)
    }


    fn max(self, oth: int): int {
        if self > oth { self }
        else { oth }
    }


    fn min(self, oth: int): int {
        if self < oth { self }
        else { oth }
    }


    fn pow(self, exp: int): int {
        var count = 1;
        for _ in 0..exp {
            count *= self;
        }
        count
    }

}


impl float {
    fn to_str(self): str {
        ffi::float_to_str(self)
    }
}


impl<T> Option<T> {
    fn map<A>(self, f: fn(T): A): Option<A> {
        match self {
            some: val => {
                some(f(val))
            },

            none => {
                none()
            }
        }
    }


    fn is_some(self): bool {
        match self {
            some => true,
            none => false,
        }
    }
}


impl Eq for int {
    fn eq(self, oth: Self): bool {
        self == oth
    }
}

impl Eq for float {
    fn eq(self, oth: Self): bool {
        self == oth
    }
}

impl Eq for bool {
    fn eq(self, oth: Self): bool {
        self == oth
    }
}

impl Eq for () {
    fn eq(self, oth: Self): bool {
        self == oth
    }
}

impl<T: Eq> Eq for [T] {
    fn eq(self, oth: Self): bool {
        self.iter().zip(oth.iter())
            .all(|a: (T, T)| a.0 == a.1)
    }
}

