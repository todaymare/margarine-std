mod duration;
mod hashmap;
mod iter;
mod list;
mod io;
mod string;


mod ffi {
    extern {
        fn print_raw<T>(val: T, ty_id: int)

        fn new_any<T>(value: T, type_id: int): any 
        fn downcast_any<T>(ptr: any, target: int): Option<T>

        fn int_to_str(value: int): str
        fn float_to_str(value: float): str
    }
}


fn println<T>(val: T) {
    ffi::print_raw(val, type_id::<T>());
    ffi::print_raw("\n", type_id::<str>());
}


fn print<T>(val: T) {
    ffi::print_raw(val, type_id::<T>());
}


impl Range {
    fn __next__(self): Option<int> {
        if self.min < self.max {
            self.min += 1;
            some(self.min-1)
        } else {
            none()
        }

    }
}


struct Box<T> { value: T }


impl<T> Box<T> {
    fn new(value: T): Box<T> { Box { value } }
}


type any


impl any {
    fn from<T>(value: T): any {
        ffi::new_any(value, type_id::<T>())
    }


    fn cast<T>(self): Option<T> {
        ffi::downcast_any::<T>(self, type_id::<T>())
    }
}


fn type_id_of<T>(val: T): int {
    type_id::<T>()
}


impl int {
    fn abs(self): int {
        var mask = self >> 63;
        (self ^ mask) - mask
    }


    fn to_str(self): str {
        ffi::int_to_str(self)
    }
}


impl float {
    fn to_str(self): str {
        ffi::float_to_str(self)
    }
}


impl<T> Option<T> {
    fn map<A>(self, f: fn(T): A): Option<A> {
        match self {
            some: val => {
                some(f(val))
            },

            none => {
                none()
            }
        }
    }
}


