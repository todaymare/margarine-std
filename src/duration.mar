struct Duration {
	secs: int,
	nanos: int,
}



mod ffi {
    extern {
        fn now_secs(): int
        fn now_nanos(): int
    }
}


impl Duration {
	/// Creates a new `Duration` from the time
	/// difference between the unix-epoch and now
	/// using the system clock
	fn now(): Duration {
		Duration::new(ffi::now_secs(), ffi::now_nanos())
	}
	
	/// Creates a new `Duration`
	/// 
	/// If the nano-seconds
	/// overflow 1 billion (number of nano-seconds in a second)
	/// it will be carried over to the next second
	///
	/// # Examples
	/// ```
	/// var duration = Duration::new(12, 0)
	///
	/// assert(duration.as_secs() == 12)
	/// assert(duration.subsec_nanos() == 0)
	/// ```
	fn new(secs: int, nanos: int): Duration {
		var secs = secs + (nanos / 1_000_000_000);
		var nanos = nanos % 1_000_000_000;
		Duration {
			secs: secs,
			nanos: nanos,
		} 
	}


    fn elapsed(self): Duration {
        Duration::now().sub(self)
    }


	/// Creates a new `Duration` from the given number
	/// of whole seconds
	/// 
	/// # Examples
	/// ```
	/// var duration = Duration::from_secs(12)
	///
	/// assert(duration.as_secs() == 12)
	/// assert(duration.subsec_nanos() == 0)
	/// ```
	fn from_secs(secs: int): Duration {
		 Duration { secs: secs, nanos: 0 }
	}


	/// Creates a new `Duration` from the given number
	/// of floating point seconds
	/// 
	/// # Examples
	/// ```
	/// var duration = Duration::from_secs(12.5)
	/// 
	/// assert(duration.as_secs() == 12)
	/// assert(duration.subsec_nanos() == 500_000_000)
	/// ```
	fn from_secs_float(secs: float): Duration {
		Duration::from_nanos((secs * 1_000_000_000.0) as int)
		
	}


	/// Creates a new `Duration` from the given milliseconds
	///
	/// # Examples
	/// ```
	/// var duration = Duration::from_millis(500)
	/// 
	/// assert(duration.as_secs() == 0)
	/// assert(duration.subsec_nanos() == 500_000_000)
	/// ```
	fn from_millis(millis: int): Duration {
		var secs = millis / 1_000;
		var nanos = ((millis % 1_000)) * 1_000_000;
		Duration { secs: secs, nanos: nanos }
	}


	/// Creates a new `Duration` from the given microseconds
	///
	/// # Examples
	/// ```
	/// var duration = Duration::from_micros(5_000_320)
	/// 
	/// assert(duration.as_secs() == 5)
	/// assert(duration.subsec_nanos() == 320_000)
	/// ```
	fn from_micros(micros: int): Duration {
		var secs = micros / 1_000_000;
		var nanos = ((micros % 1_000_000)) * 1_000;
		Duration { secs: secs, nanos: nanos }
	}


	/// Creates a new `Duration` from the given nanoseconds
	///
	/// # Examples
	/// ```
	/// var duration = Duration::from_nanos(69420)
	/// 
	/// assert(duration.as_secs() == 0)
	/// assert(duration.subsec_nanos() == 69420)
	/// ```
	fn from_nanos(nanos: int): Duration {
		var secs = (nanos / 1_000_000_000);
		var nanos = (nanos % 1_000_000_000);
		Duration { secs: secs, nanos: nanos }
	}


	/// Returns true if this `Duration` spans no time
	///
	/// ```
	/// assert(Duration::new(0, 0).is_zero())
	/// ```
	fn is_zero(self): bool {
		if self.secs == 0 { self.nanos == 0 } else { false }
	}
	

	/// Returns the amount of whole seconds in this `Duration`
	fn as_secs(self): int { self.secs }


	/// Returns the amount of seconds in this `Duration`
	fn as_secs_float(self): float { self.secs as float + (self.nanos as float / 1_000_000_000.0)}


	// Returns the amount of milliseconds in this `Duration`
	fn as_millis(self): int { self.secs * 1_000 + (self.nanos / 1_000_000) }


	// Returns the amount of microseconds in this `Duration`
	fn as_micros(self): int { self.secs * 1_000_000 + (self.nanos / 1_000) }


	// Returns the amount of nanoseconds in this `Duration`
	fn as_nanos(self): int { self.secs * 1_000_000_000 + self.nanos }


	/// Returns the amount of milliseconds
	///
	/// This is *not* the entire `Duration` but instead
	/// the part without any whole seconds
	fn subsec_millis(self): int { self.nanos / 1_000_000 }


	/// Returns the amount of microseconds
	///
	/// This is *not* the entire `Duration` but instead
	/// the part without any whole seconds
	fn subsec_micros(self): int { self.nanos / 1_000 }


	/// Returns the amount of nanoseconds
	///
	/// This is *not* the entire `Duration` but instead
	/// the part without any whole seconds
	fn subsec_nanos(self): int { self.nanos }
	

	/// Returns the time difference between two durations
	///
	/// # Examples
	/// ```
	/// var dur = Duration::new(10, 0)
	/// var oth = Duration::new(5, 0)
	///
	/// assert(dur.sub(oth).as_secs() == 5)
	/// ```
	fn sub(self, other: Duration): Duration {
		var duration_nanos = self.nanos - other.nanos;
		var duration_secs = self.secs - other.secs;
        if duration_nanos < 0 {
            duration_secs = duration_secs - 1;
            duration_nanos = 1_000_000_000 + duration_nanos;
        }

		Duration { secs: duration_secs, nanos: duration_nanos }
	}


	/// Returns the sum of two durations
	///
	/// # Examples
	/// ```
	/// var dur = Duration::new(10, 0)
	/// var oth = Duration::new(5, 0)
	///
	/// assert(dur.add(oth).as_secs() == 15)
	/// ```
	fn add(self, other: Duration): Duration {
		var duration_nanos = self.nanos + other.nanos;
		var duration_secs = self.secs + other.secs;
		if duration_nanos >= 1_000_000_000 {
            duration_secs = duration_secs + 1;
            duration_nanos = duration_nanos - 1_000_000_000;
		}

		Duration { secs: duration_secs, nanos: duration_nanos }
	}
}
