use iter::Iter;

type Lines;

impl str {
    fn lines(self): Iter<str> {
        extern {
            fn str_lines_iter(s: str): Lines
        }

        var lines = str_lines_iter(self);
        Iter {
            next: || lines.__next__(),
        }
    }




    fn split_at(self, idx: int): (str, str) {
        extern {
            fn str_split_at(s: str, idx: int): (str, str)
        }

        str_split_at(self, idx)
    }
    

    fn parse<T>(self): Option<T> {
        extern {
            fn str_parse<T>(s: str, ty: int): Option<T>
        }

        str_parse(self, type_id::<T>())
    }


    fn is_empty(self): bool {
        self.len() == 0
    }


    fn len(self): int {
        extern {
            fn str_len(s: str): int
        }

        str_len(self)
    }


    fn split(self, delimiter: str): Iter<str> {
        var state = SplitState {
            base: some(self),
            del : delimiter,
        };


        Iter {
            next: || {
                match state.base {
                    some: base => {
                        var split = state.base?.split_once(delimiter);
                        if split.is_some() {
                            var split = split!;
                            state.base = some(split.1);
                            some(split.0)
                        } else {
                            state.base = none();
                            some(base)
                        }
                    },

                    none => none(),
                }

            }
        }
    }


    fn split_once(self, delimiter: str): Option<(str, str)> {
        extern {
            fn str_split_once(s: str, delimiter: str): Option<(str, str)>
        }

        str_split_once(self, delimiter)
    }


    fn slice(self, range: Range): str {
        extern {
            fn str_slice(s: str, min: int, max: int): str
        }

        str_slice(self, range.min, range.max)
    }


    fn nth(self, n: int): str {
        extern {
            fn str_nth(s: str, n: int): str
        }

        str_nth(self, n)
    }


    fn chars(self): Iter<str> {
        var chars = Chars { s: self };
        Iter {
            next: || {
                if chars.s.is_empty() {
                    return none()
                }

                if chars.s.len() == 1 {
                    var s = chars.s;
                    chars.s = "";
                    return some(s);
                }

                var ch, rest = chars.s.split_at(1);
                chars.s = rest;
                some(ch)
            }
        }
    }
}


impl Lines {
    fn __next__(self): Option<str> {
        extern {
            fn str_lines_iter_next(s: Lines): Option<str>
        }

        str_lines_iter_next(self)
    }
}



struct SplitState {
    base: Option<str>,
    del : str,

}


struct Chars {
    s: str,
}
