struct Iter<T> {
    next: fn(): Option<T>
}


impl<T> Iter<T> {
    fn __next__(self): Option<T> {
        var next_fn = self.next;
        next_fn()
    }


    fn enumerate(self): Iter<(int, T)> {
        var counter = Box::new(0);
        Iter {
            next: || {
                var result = self.next;
                var result = result();

                match result {
                    some: result => {
                        counter.value += 1;
                        some((counter.value - 1, result))
                    },

                    none => none(),
                }
            }
        }
    }


    fn for_each(self, f: fn(T)) {
        for _ in self.map(f) {}
    }


    fn map<A>(self, f: fn(T): A): Iter<A> {
        Iter {
            next: || {
                var result = self.__next__()?;
                some(f(result))
            }
        }
    }


    fn filter(self, cond: fn(T): bool): Iter<T> {
        Iter {
            next: || {
                loop {
                    var value = self.__next__()?;
                    if cond(value) {
                        return some(value)
                    }
                }

                none()
            }
        }
    }


    fn skip(self, n: int): Iter<T> {
        for _ in 0..n { self.__next__(); }
        self
    }
}


impl Iter<int> {
    fn sum(self): int {
        var sum = (0,);
        self.for_each(|n| { sum.0 += n });
        sum.0
    }
}


